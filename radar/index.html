<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>Punk.link — Tech Radar</title>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://zalando.github.io/tech-radar/release/radar-0.12.js"></script>
        <link rel="stylesheet" href="./styles/output.css" />
    </head>
    <body> 
        <div class="flex flex-col md:flex-row gap-4 items-stretch p-3 min-h-screen box-border">
            <aside id="filters" class="w-full md:w-80 md:max-w-[40vw] md:border-r border-gray-200 md:pr-3 md:overflow-auto border-b md:border-b-0 pb-3">
                <h2 class="text-base font-semibold mb-2">Filters</h2>
                <div class="flex gap-2 mb-3">
                    <input type="text" id="searchInput" placeholder="Search techs, tags, categories..." class="flex-1 border border-gray-300 rounded px-2 py-1 text-sm" />
                    <button type="button" id="clearSearch" title="Clear search" class="px-2 py-1 text-sm border rounded">✕</button>
                </div>
                <fieldset class="border border-gray-200 rounded p-2 mb-3">
                    <legend class="font-semibold text-sm px-1">Categories</legend>
                    <div class="flex gap-2 mb-2">
                        <button type="button" id="catAll" class="px-2 py-1 text-sm border rounded">All</button>
                        <button type="button" id="catNone" class="px-2 py-1 text-sm border rounded">None</button>
                    </div>
                    <div class="max-h-64 overflow-auto pr-1 space-y-1 flex flex-col" id="categoryList"></div>
                </fieldset>
                <fieldset class="border border-gray-200 rounded p-2 mb-3">
                    <legend class="font-semibold text-sm px-1">Techs (tags)</legend>
                    <div class="flex gap-2 mb-2">
                        <button type="button" id="tagAll" class="px-2 py-1 text-sm border rounded">All</button>
                        <button type="button" id="tagNone" class="px-2 py-1 text-sm border rounded">None</button>
                    </div>
                    <div class="max-h-64 overflow-auto pr-1 space-y-1 flex flex-col" id="tagList"></div>
                </fieldset>
                <div class="flex gap-2 items-center">
                    <button type="button" id="resetFilters" class="px-2 py-1 text-sm border rounded">Reset filters</button>
                    <span class="text-gray-600 text-xs" id="matchCount"></span>
                </div>
            </aside>
            <div class="radar-container flex-1 min-w-0">
                <svg id="radar" class="w-full h-auto"></svg>
            </div>
        </div>

        <script>
            // Keep metadata of currently rendered entries for tooltip lookups
            let currentMetaByLabel = new Map();
            let currentMetaByHref = new Map();

            // Normalize labels for reliable matching between data and rendered SVG text
            function normalizeLabel(s) {
                return String(s || "")
                    .replace(/\u00A0/g, " ") // nbsp to space
                    .replace(/\s+/g, " ")
                    .trim()
                    .toLowerCase();
            }

            function normalizeHref(href) {
                try {
                    return new URL(String(href || ''), document.location.href).href;
                } catch {
                    return String(href || '').trim();
                }
            }

            (async function () {
                // Helper to render or re-render the radar with given entries
                function computeDimensions() {
                    const container = document.querySelector('.radar-container');
                    const rect = container ? container.getBoundingClientRect() : { width: 1200, top: 0 };
                    const availableWidth = Math.max(600, Math.floor(rect.width));
                    // Use distance from container top to viewport bottom to avoid being limited by sidebar height
                    const verticalPadding = 12; // matches layout padding
                    const availableHeight = Math.max(500, Math.floor(window.innerHeight - rect.top - verticalPadding));
                    // Logical canvas size used by the radar drawing
                    const BASE_WIDTH = 1450, BASE_HEIGHT = 1000, ASPECT = BASE_HEIGHT / BASE_WIDTH; // ~0.69
                    // Size the SVG viewport while preserving aspect ratio
                    const heightByAspect = Math.floor(availableWidth * ASPECT);
                    const targetHeight = Math.min(availableHeight, heightByAspect);
                    const targetWidth = availableWidth;
                    return { width: targetWidth, height: targetHeight, BASE_WIDTH, BASE_HEIGHT };
                }

                function renderRadar({ quadrants, rings, entries }) {
                    const svg = document.getElementById("radar");
                    if (svg) svg.innerHTML = ""; // clear before redraw
                    const { width, height, BASE_WIDTH, BASE_HEIGHT } = computeDimensions();
                    if (svg) {
                        // Scale the full drawing into the available viewport using viewBox
                        svg.style.height = `${height}px`;
                        svg.style.width = `100%`;
                        svg.setAttribute('width', String(width));
                        svg.setAttribute('height', String(height));
                        svg.setAttribute('viewBox', `0 0 ${BASE_WIDTH} ${BASE_HEIGHT}`);
                        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    }
                    radar_visualization({
                        repo_url: "https://github.com/punk-link/tech-radar",
                        svg_id: "radar",
                        // Keep logical dimensions constant; viewBox+CSS scale to fit viewport
                        width: BASE_WIDTH,
                        height: BASE_HEIGHT,
                        scale: 1.0,
                        colors: {
                            background: "#fff",
                            grid: "#bbb",
                            inactive: "#ddd"
                        },
                        font_family: "Arial, Helvetica",
                        title: "Punk.link — Tech Radar",
                        quadrants,
                        rings,
                        print_layout: true,
                        links_in_new_tabs: true,
                        entries
                    });
                    if (!entries || entries.length === 0) {
                        // Draw a message on top when no matches
                        if (svg && svg.namespaceURI) {
                            const msg = document.createElementNS(svg.namespaceURI, "text");
                            msg.setAttribute("x", "20");
                            msg.setAttribute("y", "40");
                            msg.setAttribute("fill", "#c00");
                            msg.textContent = "No entries match current filters";
                            svg.appendChild(msg);
                        }
                    }
                    // Update native SVG <title> tooltips for current entries (after drawing)
                    attachTooltips();
                }

                try {
                    const res = await fetch("data.json");
                    if (!res.ok) {
                        throw new Error(`Failed to load data.json: ${res.status} ${res.statusText}`);
                    }
                    const data = await res.json();

                    const ringNames = Array.isArray(data.rings) ? data.rings : [];
                    const quadrantNames = Array.isArray(data.quadrants) ? data.quadrants : [];

                    const ringIndexByName = new Map(
                        ringNames.map((n, i) => [String(n).toLowerCase(), i])
                    );
                    const quadIndexByName = new Map(
                        quadrantNames.map((n, i) => [String(n).toLowerCase(), i])
                    );

                    // Default palette covering at least four rings; cycles if more
                    const ringPalette = ["#5ba300", "#009eb0", "#c7ba00", "#e09b96", "#9b59b6", "#34495e"]; 

                    const rings = ringNames.map((name, i) => ({ name, color: ringPalette[i % ringPalette.length] }));
                    const quadrants = quadrantNames.map((name) => ({ name }));

                    const sourceEntries = (Array.isArray(data.entries) ? data.entries : []);
                    const entries = sourceEntries.map((e, idx) => {
                        const qIdx = quadIndexByName.get(String(e.quadrant ?? "").toLowerCase());
                        const rIdx = ringIndexByName.get(String(e.ring ?? "").toLowerCase());
                        return {
                            id: e.id ?? `entry-${idx}`,
                            label: e.label ?? e.id ?? `Entry ${idx + 1}`,
                            quadrant: typeof qIdx === "number" ? qIdx : 0,
                            ring: typeof rIdx === "number" ? rIdx : 0,
                            moved: typeof e.moved === "number" ? e.moved : 0,
                            link: e.url,
                            active: e.active !== false,
                            // keep original fields to support filtering without re-mapping
                            _category: e.category,
                            _tags: Array.isArray(e.tags) ? e.tags : [],
                            _desc: e.description || "",
                            _url: e.url || ''
                        };
                    });

                    // Build filter sets from data
                    const allCategories = new Set(
                        (Array.isArray(data.categories) ? data.categories : [])
                            .concat(sourceEntries.map(e => e.category).filter(Boolean))
                    );
                    const allTags = new Set(
                        sourceEntries.flatMap(e => Array.isArray(e.tags) ? e.tags : [])
                    );

                    // Render filter controls
                    const categoryList = document.getElementById("categoryList");
                    const tagList = document.getElementById("tagList");
                    const matchCount = document.getElementById("matchCount");
                    const searchInput = document.getElementById("searchInput");
                    const clearSearchBtn = document.getElementById("clearSearch");

                    function createCheckbox(name, value, checked = true) {
                        const id = `${name}-${value}`.replace(/[^a-z0-9_-]/gi, "_");
                        const wrapper = document.createElement("label");
                        wrapper.className = "flex items-center gap-2 text-sm py-0.5";
                        const input = document.createElement("input");
                        input.type = "checkbox";
                        input.name = name;
                        input.value = value;
                        input.id = id;
                        input.checked = checked;
                        const span = document.createElement("span");
                        span.textContent = value;
                        wrapper.appendChild(input);
                        wrapper.appendChild(span);
                        return wrapper;
                    }

                    function populateList(container, name, values) {
                        container.innerHTML = "";
                        Array.from(values).sort((a, b) => String(a).localeCompare(String(b))).forEach(v => {
                            container.appendChild(createCheckbox(name, v, true));
                        });
                    }

                    populateList(categoryList, "category", allCategories);
                    populateList(tagList, "tag", allTags);

                    function selected(name) {
                        return new Set(
                            Array.from(document.querySelectorAll(`input[name="${name}"]`))
                                .filter(i => i.checked)
                                .map(i => i.value)
                        );
                    }

                    function applyFilters() {
                        const selectedCategories = selected("category");
                        const selectedTags = selected("tag");
                        const q = (searchInput.value || "").toLowerCase().trim();

                        const filtered = entries.filter(e => {
                            const catOk = selectedCategories.size === 0 || selectedCategories.has(e._category);
                            const tags = e._tags || [];
                            const tagOk = selectedTags.size === 0 || tags.some(t => selectedTags.has(t));
                            const searchOk = q.length === 0 ||
                                (e.label && e.label.toLowerCase().includes(q)) ||
                                (e.id && e.id.toLowerCase().includes(q)) ||
                                (e._category && String(e._category).toLowerCase().includes(q)) ||
                                (e._desc && e._desc.toLowerCase().includes(q)) ||
                                tags.some(t => String(t).toLowerCase().includes(q));
                            return catOk && tagOk && searchOk;
                        });

                        matchCount.textContent = `${filtered.length} match${filtered.length === 1 ? "" : "es"}`;
                        // Save meta for tooltips, then map back to radar entry shape (exclude helper fields)
                        currentMetaByLabel = new Map(
                            filtered.map(e => [normalizeLabel(e.label), { category: e._category, tags: e._tags, ring: rings[e.ring]?.name, quadrant: quadrants[e.quadrant]?.name, desc: e._desc, href: normalizeHref(e._url) }])
                        );
                        currentMetaByHref = new Map(
                            filtered.map(e => [normalizeHref(e._url), { category: e._category, tags: e._tags, ring: rings[e.ring]?.name, quadrant: quadrants[e.quadrant]?.name, desc: e._desc, label: e.label }])
                        );
                        const mapped = filtered.map(({ _category, _tags, _desc, ...rest }) => rest);
                        renderRadar({ quadrants, rings, entries: mapped });
                    }

                    // Wire control buttons
                    function setAll(name, value) {
                        document.querySelectorAll(`input[name="${name}"]`).forEach(i => { i.checked = value; });
                        applyFilters();
                    }
                    document.getElementById("catAll").addEventListener("click", () => setAll("category", true));
                    document.getElementById("catNone").addEventListener("click", () => setAll("category", false));
                    document.getElementById("tagAll").addEventListener("click", () => setAll("tag", true));
                    document.getElementById("tagNone").addEventListener("click", () => setAll("tag", false));
                    document.getElementById("resetFilters").addEventListener("click", () => {
                        setAll("category", true);
                        setAll("tag", true);
                        searchInput.value = "";
                    });

                    // React on checkbox changes
                    document.getElementById("filters").addEventListener("change", (e) => {
                        const target = e.target;
                        if (target && target.matches && target.matches('input[type="checkbox"]')) {
                            applyFilters();
                        }
                    });

                    // Debounced search
                    function debounce(fn, wait) {
                        let t;
                        return function(...args) {
                            clearTimeout(t);
                            t = setTimeout(() => fn.apply(this, args), wait);
                        };
                    }
                    const onSearch = debounce(() => applyFilters(), 200);
                    searchInput.addEventListener("input", onSearch);
                    clearSearchBtn.addEventListener("click", () => { searchInput.value = ""; applyFilters(); });

                    // Resize handling: recompute dimensions and re-apply current filters
                    const onResize = debounce(() => applyFilters(), 150);
                    window.addEventListener('resize', onResize);

                    // Initial render + initial meta
                    currentMetaByLabel = new Map(
                        entries.map(e => [normalizeLabel(e.label), { category: e._category, tags: e._tags, ring: rings[e.ring]?.name, quadrant: quadrants[e.quadrant]?.name, desc: e._desc, href: normalizeHref(e._url) }])
                    );
                    currentMetaByHref = new Map(
                        entries.map(e => [normalizeHref(e._url), { category: e._category, tags: e._tags, ring: rings[e.ring]?.name, quadrant: quadrants[e.quadrant]?.name, desc: e._desc, label: e.label }])
                    );
                    renderRadar({ quadrants, rings, entries: entries.map(({ _category, _tags, _desc, ...rest }) => rest) });
                    matchCount.textContent = `${entries.length} matches`;
                } catch (err) {
                    console.error(err);
                    // Render a simple inline error message so the page isn't blank
                    const svg = document.getElementById("radar");
                    if (svg && svg.namespaceURI) {
                        const msg = document.createElementNS(svg.namespaceURI, "text");
                        msg.setAttribute("x", "20");
                        msg.setAttribute("y", "40");
                        msg.setAttribute("fill", "#c00");
                        msg.textContent = "Failed to load radar data.json";
                        svg.appendChild(msg);
                    }
                }
            })();

            // After render, add/update SVG <title> on text and blip anchor nodes to show rich tooltips
            function attachTooltips() {
                const svg = document.getElementById('radar');
                if (!svg) return;
                const ns = svg.namespaceURI;
                
                // 1) Tooltips for side labels (text elements)
                const texts = svg.querySelectorAll('text');
                texts.forEach(textEl => {
                    const raw = (textEl.textContent || '').trim();
                    if (!raw) return;
                    const meta = currentMetaByLabel.get(normalizeLabel(raw));
                    if (!meta) return;

                    const lines = [
                        raw,
                        `Quadrant: ${meta?.quadrant || '—'}`,
                        `Ring: ${meta?.ring || '—'}`,
                        `Category: ${meta?.category || '—'}`,
                        `Tags: ${(meta?.tags && meta.tags.length) ? meta.tags.join(', ') : '—'}`,
                    ];
                    if (meta?.desc) lines.push(`Description: ${meta.desc}`);

                    const targets = new Set();
                    targets.add(textEl);
                    const a = textEl.closest('a'); if (a) targets.add(a);
                    const g = textEl.closest('g'); if (g) targets.add(g);

                    targets.forEach(el => {
                        let t = el.querySelector('title');
                        if (!t) {
                            t = document.createElementNS(ns, 'title');
                            el.insertBefore(t, el.firstChild);
                        }
                        t.textContent = lines.join('\n');
                    });
                });

                // 2) Tooltips for blips (anchor elements with href)
                const anchors = svg.querySelectorAll('a');
                anchors.forEach(a => {
                    const href = a.getAttribute('href') || a.getAttribute('xlink:href') || a.href || '';
                    const meta = currentMetaByHref.get(normalizeHref(href));
                    if (!meta) return;
                    const label = meta.label || '';
                    const lines = [
                        label,
                        `Quadrant: ${meta?.quadrant || '—'}`,
                        `Ring: ${meta?.ring || '—'}`,
                        `Category: ${meta?.category || '—'}`,
                        `Tags: ${(meta?.tags && meta.tags.length) ? meta.tags.join(', ') : '—'}`,
                    ];
                    if (meta?.desc) lines.push(`Description: ${meta.desc}`);
                    let t = a.querySelector('title');
                    if (!t) {
                        t = document.createElementNS(ns, 'title');
                        a.insertBefore(t, a.firstChild);
                    }
                    t.textContent = lines.join('\n');
                });
            }
        </script>
    </body>
</html>